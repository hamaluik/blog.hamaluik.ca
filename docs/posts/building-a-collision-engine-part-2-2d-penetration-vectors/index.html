<!DOCTYPE html> <html lang="en-CA"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>Building a Collision Engine Part 2: 2D Penetration Vectors</title> <link rel="alternate" type="application/rss+xml" href="https://blog.hamaluik.ca/feed.rss" title="Posts RSS"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> <link rel="manifest" href="/site.webmanifest"> <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#ff5555"> <meta name="msapplication-TileColor" content="#ff5555"> <meta name="theme-color" content="#ff5555"> <meta property="og:title" content="Building a Collision Engine Part 2: 2D Penetration Vectors"/> <meta property="og:url" content="http://blog.hamaluik.ca/posts/building-a-collision-engine-part-2-2d-penetration-vectors/"/> <meta property="og:image" content="https://og-image.now.sh/Building%20a%20Collision%20Engine%20Part%202%3A%202D%20Penetration%20Vectors.png?theme=light&md=0&fontSize=75px&images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fhyper-color-logo.svg&widths=350&heights=350"/> <meta property="og:description" content="In my last post, I discussed how to determine if any two convex shapes in two dimensions overlap. The result of this calculation is a boolean state—either the two are colliding or they aren&#x27;t. This is great for things such as triggers, but if you want to use the collision engine for any type of physics calculations, you&#x27;ll need at least one more crucial piece of information: the penetration vector. This post discusses how to calculate the penetration vector using the EPA algorithm."/> <meta property="og:type" content="article"/> <meta property="og:locale" content="en_CA"/> <meta property="og:site_name" content="Kenton Hamaluik"/> <meta property="article:published_time" content=" 2017-06-11T07:00:00+00:00 "/> <meta property="article:author" content="http://blog.hamaluik.ca/"/> <meta property="article:tag" content="Math"/> <meta property="article:tag" content="Haxe"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:image:alt" content="Building a Collision Engine Part 2: 2D Penetration Vectors"/> <style> @font-face {font-family:"Crimson Pro";font-style:italic;font-weight:400;font-display:swap;src:local("Crimson Pro Italic"),local("CrimsonPro Italic"),local("Crimson-Pro-Italic"),local("CrimsonPro-Italic"),url(/fonts/crimson-pro-normal-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Italic.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:italic;font-weight:400;font-display:swap;src:local("Crimson Pro Italic"),local("CrimsonPro Italic"),local("Crimson-Pro-Italic"),local("CrimsonPro-Italic"),url(/fonts/crimson-pro-italic-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Italic.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:400;font-display:swap;src:local("Crimson Pro"),local("CrimsonPro"),local("Crimson-Pro"),local("CrimsonPro"),url(/fonts/crimson-pro-normal-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Regular.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:400;font-display:swap;src:local("Crimson Pro"),local("CrimsonPro"),local("Crimson-Pro"),local("CrimsonPro"),url(/fonts/crimson-pro-normal-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Regular.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:700;font-display:swap;src:local("Crimson Pro Bold"),local("CrimsonPro Bold"),local("Crimson-Pro-Bold"),local("CrimsonPro-Bold"),url(/fonts/crimson-pro-bold-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Bold.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:700;font-display:swap;src:local("Crimson Pro Bold"),local("CrimsonPro Bold"),local("Crimson-Pro-Bold"),local("CrimsonPro-Bold"),url(/fonts/crimson-pro-bold-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Bold.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Eczar";font-style:normal;font-weight:700;font-display:swap;src:local("Eczar Bold"),local("Eczar-Bold"),url(/fonts/eczar-bold-latin-ext.woff2) format("woff2"),url(/fonts/Eczar-Bold.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Eczar";font-style:normal;font-weight:700;font-display:swap;src:local("Eczar Bold"),local("Eczar-Bold"),url(/fonts/eczar-bold-latin.woff2) format("woff2"),url(/fonts/Eczar-Bold.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}:root{--theme-background:#282a36;--theme-currentline:#44475a;--theme-selection:#44475a;--theme-foreground:#f8f8f2;--theme-comment:#6272a4;--theme-cyan:#8be9fd;--theme-green:#50fa7b;--theme-orange:#ffb86c;--theme-pink:#ff79c6;--theme-purple:#bd93f9;--theme-red:#ff5555;--theme-yellow:#f1fa8c;}body{margin:1em auto;max-width:36em;line-height:1.2;color:var(--theme-background);background:var(--theme-foreground);padding:0 0.5em;font-family:"Crimson Pro",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;font-size:16pt;}h1,h2,h3{line-height:1.2;font-family:"Eczar",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;font-weight:800;font-size:32pt;margin-bottom:0;}h2{font-size:28pt;}h3{font-size:20pt;}h1 a,h2 a,h3 a{text-decoration:none;}body>header>h1{font-size:48pt;font-weight:800;}p{text-align:justify;margin:0;hyphens:auto;}p+p{text-indent:2em;}a{color:var(--theme-background);text-decoration:underline;text-decoration-color:var(--theme-red);}body>header>h1{margin:0;padding:0;border-bottom:5px dashed var(--theme-red);line-height:1;}body>header>h1>a{font-style:normal;word-break:normal;}a:hover,a:focus,a:active{color:var(--theme-red);text-decoration:none;}ul.postlist{padding:0;list-style-type:none;margin-top:0;margin-bottom:1em;}ul.postlist>li::before{width:1em;height:1em;margin-left:-1em;display:inline-flex;align-items:center;justify-content:start;}ul.postlist>li{padding-left:1em;}ul.postlist>li a{text-decoration:none;}ul.postlist>li>time,article>header>h1>time{font-size:10pt;color:var(--theme-red);font-weight:normal;font-family:"Crimson Pro",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;}ul:not(.postlist)>li{overflow-wrap:break-word;}article figure{display:block;text-align:center;}article figure img,article figure video{max-width:100%;}img.white{mix-blend-mode:multiply;}article figure figcaption{display:block;font-size:10pt;text-align:center;margin-bottom:0.5em;}:not(pre)>code{word-break:break-all;font-family:"Source Code Pro","Fira Code","Fira Mono",Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;font-size:0.75em;}pre,figure{overflow-x:auto;}body>header{margin-bottom:1em;}footer{font-size:10pt;margin-top:1em;border-top:5px dashed var(--theme-red);padding-top:0.5em;display:flex;flex-direction:column;align-items:flex-start;}footer a.has-icon{display:inline-flex;flex-direction:row;align-items:center;}footer a.has-icon>svg{margin-right:0.5em;}footer svg{width:auto;height:1em;fill:currentColor;stroke:currentColor;}blockquote{border-left:5px dashed var(--theme-red);margin:1em;padding:0 calc(0.5em + 4px) 0 0.5em;}footer>span{display:block;}svg{color:var(--theme-background);fill:currentColor;}@media (prefers-color-scheme:dark){body{background-color:var(--theme-background);color:var(--theme-foreground);}a{color:var(--theme-foreground);text-decoration-color:var(--theme-cyan);}svg{color:var(--theme-foreground);fill:currentColor;}body>header>h1{border-bottom-color:var(--theme-cyan);}ul.postlist>li>time,article>header>h1>time{color:var(--theme-cyan);}:not(pre)>code{}footer{border-top-color:var(--theme-cyan);}blockquote{border-left-color:var(--theme-cyan);}.highlight{background:#21222c;}img.white{filter:invert(100%) hue-rotate(180deg);mix-blend-mode:screen;}}.highlight{font-family:"Source Code Pro","Fira Code","Fira Mono",Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;font-size:12pt;padding:0.25em;background:var(--theme-background);color:var(--theme-foreground);margin:1em 0;}.highlight>pre{margin:0;}.highlight{background:var(--theme-background);color:var(--theme-foreground);}.highlight .hll{background-color:var(--theme-yellow);}.highlight .c{color:var(--theme-comment);}.highlight .err{color:var(--theme-foreground);}.highlight .g{color:var(--theme-foreground);}.highlight .k{color:var(--theme-pink);}.highlight .l{color:var(--theme-foreground);}.highlight .n{color:var(--theme-foreground);}.highlight .o{color:var(--theme-pink);}.highlight .x{color:var(--theme-foreground);}.highlight .p{color:var(--theme-foreground);}.highlight .ch{color:var(--theme-comment);}.highlight .cm{color:var(--theme-comment);}.highlight .cp{color:var(--theme-pink);}.highlight .cpf{color:var(--theme-comment);}.highlight .c1{color:var(--theme-comment);}.highlight .cs{color:var(--theme-comment);}.highlight .gd{color:#8b080b;}.highlight .ge{color:var(--theme-foreground);text-decoration:underline;}.highlight .gr{color:var(--theme-foreground);}.highlight .gh{color:var(--theme-foreground);font-weight:bold;}.highlight .gi{color:var(--theme-foreground);font-weight:bold;}.highlight .go{color:var(--theme-currentline);}.highlight .gp{color:var(--theme-foreground);}.highlight .gs{color:var(--theme-foreground);}.highlight .gu{color:var(--theme-foreground);font-weight:bold;}.highlight .gt{color:var(--theme-foreground);}.highlight .kc{color:var(--theme-pink);}.highlight .kd{color:var(--theme-cyan);font-style:italic;}.highlight .kn{color:var(--theme-pink);}.highlight .kp{color:var(--theme-pink);}.highlight .kr{color:var(--theme-pink);}.highlight .kt{color:var(--theme-cyan);}.highlight .ld{color:var(--theme-foreground);}.highlight .m{color:var(--theme-purple);}.highlight .s{color:var(--theme-yellow);}.highlight .na{color:var(--theme-green);}.highlight .nb{color:var(--theme-cyan);font-style:italic;}.highlight .nc{color:var(--theme-green);}.highlight .no{color:var(--theme-foreground);}.highlight .nd{color:var(--theme-foreground);}.highlight .ni{color:var(--theme-foreground);}.highlight .ne{color:var(--theme-foreground);}.highlight .nf{color:var(--theme-green);}.highlight .nl{color:var(--theme-cyan);font-style:italic;}.highlight .nn{color:var(--theme-foreground);}.highlight .nx{color:var(--theme-foreground);}.highlight .py{color:var(--theme-foreground);}.highlight .nt{color:var(--theme-pink);}.highlight .nv{color:var(--theme-cyan);font-style:italic;}.highlight .ow{color:var(--theme-pink);}.highlight .w{color:var(--theme-foreground);}.highlight .mb{color:var(--theme-purple);}.highlight .mf{color:var(--theme-purple);}.highlight .mh{color:var(--theme-purple);}.highlight .mi{color:var(--theme-purple);}.highlight .mo{color:var(--theme-purple);}.highlight .sa{color:var(--theme-yellow);}.highlight .sb{color:var(--theme-yellow);}.highlight .sc{color:var(--theme-yellow);}.highlight .dl{color:var(--theme-yellow);}.highlight .sd{color:var(--theme-yellow);}.highlight .s2{color:var(--theme-yellow);}.highlight .se{color:var(--theme-yellow);}.highlight .sh{color:var(--theme-yellow);}.highlight .si{color:var(--theme-yellow);}.highlight .sx{color:var(--theme-yellow);}.highlight .sr{color:var(--theme-yellow);}.highlight .s1{color:var(--theme-yellow);}.highlight .ss{color:var(--theme-yellow);}.highlight .bp{color:var(--theme-foreground);font-style:italic;}.highlight .fm{color:var(--theme-green);}.highlight .vc{color:var(--theme-cyan);font-style:italic;}.highlight .vg{color:var(--theme-cyan);font-style:italic;}.highlight .vi{color:var(--theme-cyan);font-style:italic;}.highlight .vm{color:var(--theme-cyan);font-style:italic;}.highlight .il{color:var(--theme-purple);}.slideshow{width:512px;box-sizing:border-box;text-align:center;overflow:hidden;margin:0 auto;}.slideshow a{display:inline-flex;width:1.5rem;height:1.5rem;background:var(--theme-foreground);color:var(--theme-background);text-decoration:none;align-items:center;justify-content:center;border-radius:50%;margin:0 0 0.5rem 0;position:relative;}.slideshow a:focus,.slideshow a:hover,.slideshow a:active{color:var(--theme-foreground);background:var(--theme-background);}@supports (scroll-snap-type){.slideshow a{display:none;}}.slideshow .slides{display:flex;overflow-x:auto;scroll-snap-type:x mandatory;scroll-behavior:smooth;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--theme-foreground) transparent;}.slideshow .slides img{scroll-snap-align:start;flex-shrink:0;width:512px;height:512px;margin-right:50px;border-radius:10px;transform-origin:center center;transform:scale(1);transition:transform 0.5s;position:relative;}.slideshow .slides::-webkit-scrollbar{width:10px;height:10px;}.slideshow .slides::-webkit-scrollbar-thumb{background:var(--theme-foreground);border-radius:10px;}.slideshow .slides::-webkit-scrollbar-track{background:transparent;}@media (prefers-color-scheme:dark){.slideshow a{color:var(--theme-foreground);background:var(--theme-background);}.slideshow a:focus,.slideshow a:hover,.slideshow a:active{background:var(--theme-foreground);color:var(--theme-background);}}</style> </head> <body> <header> <h1><a href="https://blog.hamaluik.ca/">Kenton Hamaluik</a></h1> </header> <article> <header> <h1> Building a Collision Engine Part 2: 2D Penetration Vectors <time datetime='2017-06-11T07:00:00+00:00'>(2017-06-11)</time> </h1> </header> <p>In my <a href="/posts/building-a-collision-engine-part-1-2d-gjk-collision-detection/">last post</a>, I discussed how to determine if any two convex shapes in two dimensions overlap. The result of this calculation is a boolean state—either the two are colliding or they aren’t. This is great for things such as triggers, but if you want to use the collision engine for any type of physics calculations, you’ll need at least one more crucial piece of information: the penetration vector.</p> <p>The penetration vector of two shapes is a vector which describes the overlap of those two shapes. By adding the penetration vector to one of the shapes, the shapes can be separated so that they are just touching, but not really intersecting. Without any extra information, this vector chosen as the one that separate the two shapes along the shortest path possible, which can lead to some issues at the corners of polygons but is often exactly what we want.</p> <p>In my collision engine, I’ve decided to implement the calculation of this penetration vector using the <a href="http://www.dyn4j.org/2010/05/epa-expanding-polytope-algorithm/">EPA</a> method. This method again makes use of the same support functions we used to calculate whether we were colliding or not. The reason for this is that the penetration vector is the distance from the origin to the Minkowski difference, whether the Minkowski difference contains the origin or not.</p> <figure> <img src="/images/collision-engine-2d-penetration/penetration-vector-md-origin.svg"> <figcaption>The penetration vector of two overlapping shapes is the distance of the Minkowski difference to the origin.</figcaption> </figure> <h3><a href="#the-epa-method" aria-hidden="true" class="anchor" id="headerthe-epa-method"></a>The EPA Method</h3> <p>The EPA (Expanding Polytope Algorithm) works well with Minkowski differences because it uses many of the same concepts—namely support functions and simplexes. However, instead of trying to use the support functions to construct a simplex which encases the origin, EPA seeks to use the support functions to find the boundaries of the Minkowski difference in an attempt to find the boundary that is closest to the origin. In order to do this, the algorithm starts with a simplex contained within the Minkowski difference (we might as well use the one from the previous step!), then “expands” it into higher vertex count polygons (gradually approaching the true Minkowski difference polygon) until one of the edges is found to be the closest to the origin.</p> <figure> <img src="/images/collision-engine-2d-penetration/search-closest.svg"> <figcaption>EPA "searches" for the edge of the polytope which is closest to the origin.</figcaption> </figure> <p>We start by finding the closest edge in our simplex to the origin:</p> <div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">function</span> <span class="nf">findClosestEdge</span><span class="p">(</span><span class="n">winding</span><span class="p">:</span><span class="n">PolygonWinding</span><span class="p">):</span><span class="n">Edge</span> <span class="p">{</span>
    <span class="kd">var</span> closestDistance<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">;</span>
    <span class="kd">var</span> closestNormal<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>
    <span class="kd">var</span> closestIndex<span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">var</span> edge<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>

    <span class="c1">// loop through all the vertices (each edge will be vertex i -&gt; vertex j)</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="n">vertices</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> j<span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">vertices</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// wrap</span>

        <span class="c1">// calculate the edge as v[j] - v[i]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">copy</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">subtractVec</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">edge</span><span class="p">);</span>

        <span class="c1">// quickly calculate the outward-facing normal of the edge</span>
        <span class="c1">// (make use of the polygon winding to do this in 2D easily)</span>
        <span class="kd">var</span> norm<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">switch</span><span class="p">(</span><span class="n">winding</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">Clockwise</span><span class="p">:</span>
                <span class="k">new</span> <span class="n">Vec2</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">edge</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
            <span class="k">case</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">CounterClockwise</span><span class="p">:</span>
                <span class="k">new</span> <span class="n">Vec2</span><span class="p">(</span><span class="o">-</span><span class="n">edge</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">norm</span><span class="p">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span>

        <span class="c1">// calculate how far away the edge is from the origin</span>
        <span class="kd">var</span> dist<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">norm</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="c1">// we&#39;re looking for the closest edge!</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">closestDistance</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">closestDistance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
            <span class="n">closestNormal</span> <span class="o">=</span> <span class="n">norm</span><span class="p">;</span>
            <span class="n">closestIndex</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">Edge</span><span class="p">(</span><span class="n">closestDistance</span><span class="p">,</span> <span class="n">closestNormal</span><span class="p">,</span> <span class="n">closestIndex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div> <p>Once we have the edge in our polygon which is the closest to the origin, try to find a support point in the direction of the edge’s normal direction to see if there might be something closer to the origin (that exists in the Minkowski difference, but not our simplex yet):</p> <div class="highlight"><pre><span></span><span class="kd">var</span> edge<span class="p">:</span><span class="n">Edge</span> <span class="o">=</span> <span class="n">findClosestEdge</span><span class="p">(</span><span class="n">simplexWinding</span><span class="p">);</span>
<span class="kd">var</span> support<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="n">calculateSupport</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
<span class="kd">var</span> distance<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">support</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">distance</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EPSILON</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we found the edge in the Minkowski difference that is closest to the origin!</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// there&#39;s likely an edge in the Minkowski difference that is closer to the origin..</span>
<span class="p">}</span>
</pre></div> <figure> <img src="/images/collision-engine-2d-penetration/search-further-supports.svg"> <figcaption>If there is a support point sufficiently far away from our edge in it's normal direction, we haven't found the edge closest to the origin.</figcaption> </figure> <p>If we <em>did</em> find the edge closest to the origin, the support point in the direction of the edge’s normal should lie on the edge itself. In this case, we can return the penetration vector as:</p> <div class="highlight"><pre><span></span><span class="n">intersection</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">intersection</span><span class="p">);</span>
<span class="n">intersection</span><span class="p">.</span><span class="n">multiplyScalar</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">intersection</span><span class="p">);</span>
</pre></div> <p>On the other hand, if we found that we <em>didn’t</em> find the edge closest to the origin, we can <strong>expand</strong> the simplex toward the support point and try again:</p> <div class="highlight"><pre><span></span><span class="n">vertices</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">support</span><span class="p">);</span>
</pre></div> <figure> <img src="/images/collision-engine-2d-penetration/search-expanded-simplex.svg"> <figcaption>Expand the simplex to try again.</figcaption> </figure> <p>Once we’ve expanded our simplex (for the first iteration the simplex will go from having 3 to having 4 vertices), we run the algorithm again, searching for the closest edge and determining if the support point along its normal lies on the edge or not. We can continue this process until we find the <em>de-facto</em> closest edge or we hit some upper limit of iterations that we’re willing to try. The code for calculating the intersection now looks like this:</p> <div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">function</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">shapeA</span><span class="p">:</span><span class="n">Shape2D</span><span class="p">,</span> <span class="n">shapeB</span><span class="p">:</span><span class="n">Shape2D</span><span class="p">):</span><span class="n">Null</span><span class="p">&lt;</span><span class="n">Vec2</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">var</span> intersection<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> edge<span class="p">:</span><span class="n">Edge</span> <span class="o">=</span> <span class="n">findClosestEdge</span><span class="p">(</span><span class="n">PolygonWinding</span><span class="p">.</span><span class="n">Clockwise</span><span class="p">);</span>
        <span class="kd">var</span> support<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="n">calculateSupport</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kd">var</span> distance<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">support</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">intersection</span><span class="p">);</span>
        <span class="n">intersection</span><span class="p">.</span><span class="n">multiplyScalar</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">intersection</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">distance</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EPSILON</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">intersection</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">vertices</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">support</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">intersection</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <figure> <img src="/images/collision-engine-2d-penetration/search-support-on-edge.svg"> <figcaption>Search until we find a support vertex that lies on our closest edge.</figcaption> </figure> <p>One last thing we can do is actually calculate the polygon winding of the simplex we’re given so that we can pass it into our <code>findClosestEdge</code> function. This is relatively straightforward:</p> <div class="highlight"><pre><span></span><span class="c1">// calculate the winding of the existing simplex</span>
<span class="kd">var</span> e0<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
<span class="kd">var</span> e1<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
<span class="kd">var</span> e2<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
<span class="kd">var</span> winding<span class="p">:</span><span class="n">PolygonWinding</span> <span class="o">=</span>
    <span class="k">if</span><span class="p">(</span><span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">Clockwise</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">CounterClockwise</span><span class="p">;</span>
</pre></div> <h2><a href="#putting-it-all-together" aria-hidden="true" class="anchor" id="headerputting-it-all-together"></a>Putting it All Together</h2> <p>We can now extend the class from the <a href="/posts/building-a-collision-engine-part-1-2d-gjk-collision-detection/">previous post</a> to include penetration vector calculation by adding the following. What you do with the penetration vector depends on your goal. If you’re creating a physics system, you can use these vectors to resolve collision responses (pushing objects apart based on physical properties like mass and elasticity for example).</p> <h4><a href="#gjk2dhx" aria-hidden="true" class="anchor" id="headergjk2dhx"></a>GJK2D.hx</h4> <div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kd">enum</span> <span class="n">PolygonWinding</span> <span class="p">{</span>
    <span class="n">Clockwise</span><span class="p">;</span>
    <span class="n">CounterClockwise</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="n">Edge</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">var</span> distance<span class="p">:</span><span class="n">Float</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kd">var</span> normal<span class="p">:</span><span class="n">Vec2</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kd">var</span> index<span class="p">:</span><span class="n">Int</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">(</span><span class="n">distance</span><span class="p">:</span><span class="n">Float</span><span class="p">,</span> <span class="n">normal</span><span class="p">:</span><span class="n">Vec2</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="n">GJK2D</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kd">private</span> <span class="kd">function</span> <span class="nf">findClosestEdge</span><span class="p">(</span><span class="n">winding</span><span class="p">:</span><span class="n">PolygonWinding</span><span class="p">):</span><span class="n">Edge</span> <span class="p">{</span>
        <span class="kd">var</span> closestDistance<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">;</span>
        <span class="kd">var</span> closestNormal<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>
        <span class="kd">var</span> closestIndex<span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">var</span> line<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="n">vertices</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> j<span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">vertices</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">copy</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="n">line</span><span class="p">.</span><span class="n">subtractVec</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line</span><span class="p">);</span>

            <span class="kd">var</span> norm<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">switch</span><span class="p">(</span><span class="n">winding</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">Clockwise</span><span class="p">:</span>
                    <span class="k">new</span> <span class="n">Vec2</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">line</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
                <span class="k">case</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">CounterClockwise</span><span class="p">:</span>
                    <span class="k">new</span> <span class="n">Vec2</span><span class="p">(</span><span class="o">-</span><span class="n">line</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">line</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">norm</span><span class="p">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span>

            <span class="c1">// calculate how far away the edge is from the origin</span>
            <span class="kd">var</span> dist<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">norm</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">closestDistance</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">closestDistance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
                <span class="n">closestNormal</span> <span class="o">=</span> <span class="n">norm</span><span class="p">;</span>
                <span class="n">closestIndex</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="n">Edge</span><span class="p">(</span><span class="n">closestDistance</span><span class="p">,</span> <span class="n">closestNormal</span><span class="p">,</span> <span class="n">closestIndex</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">shapeA</span><span class="p">:</span><span class="n">Shape2D</span><span class="p">,</span> <span class="n">shapeB</span><span class="p">:</span><span class="n">Shape2D</span><span class="p">):</span><span class="n">Null</span><span class="p">&lt;</span><span class="n">Vec2</span><span class="p">&gt;</span> <span class="p">{</span>
        <span class="c1">// first, calculate the base simplex</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">(</span><span class="n">shapeA</span><span class="p">,</span> <span class="n">shapeB</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// if we&#39;re not intersecting, return null</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// calculate the winding of the existing simplex</span>
        <span class="kd">var</span> e0<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
        <span class="kd">var</span> e1<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
        <span class="kd">var</span> e2<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
        <span class="kd">var</span> winding<span class="p">:</span><span class="n">PolygonWinding</span> <span class="o">=</span>
            <span class="k">if</span><span class="p">(</span><span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">Clockwise</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">PolygonWinding</span><span class="p">.</span><span class="n">CounterClockwise</span><span class="p">;</span>

        <span class="kd">var</span> intersection<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec2</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> edge<span class="p">:</span><span class="n">Edge</span> <span class="o">=</span> <span class="n">findClosestEdge</span><span class="p">(</span><span class="n">winding</span><span class="p">);</span>
            <span class="kd">var</span> support<span class="p">:</span><span class="n">Vec2</span> <span class="o">=</span> <span class="n">calculateSupport</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
            <span class="kd">var</span> distance<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">support</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

            <span class="n">intersection</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">intersection</span><span class="p">);</span>
            <span class="n">intersection</span><span class="p">.</span><span class="n">multiplyScalar</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">intersection</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">distance</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.000001</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">intersection</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">vertices</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">support</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">intersection</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <h2><a href="#demo" aria-hidden="true" class="anchor" id="headerdemo"></a>Demo</h2> <figure> <iframe style="width: 100%; height: 200px; border: 0;" src="/images/collision-engine-2d-penetration/demo.html"></iframe> </figure> <h2><a href="#headbutt" aria-hidden="true" class="anchor" id="headerheadbutt"></a>Headbutt</h2> <p>I’ve started rolling this code into it’s own library, tentatively called <em>Headbutt</em>, which you can follow along with if you’re interested on Github: <a href="https://github.com/hamaluik/headbutt">https://github.com/hamaluik/headbutt</a>.</p> <script src="/ruffle/ruffle.js"></script> </article> <footer> <span>© 2021 <a href="https://hamaluik.ca">Kenton Hamaluik</a></span> <span><a class="has-icon" href="https://blog.hamaluik.ca/feed.rss"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"></rect><path d="M48,144a64,64,0,0,1,64,64" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><path d="M48,96A112,112,0,0,1,160,208" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><path d="M48,48A160,160,0,0,1,208,208" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><circle cx="52" cy="204" r="12"></circle></svg> Subscribe</a></span> </footer> </body> </html>